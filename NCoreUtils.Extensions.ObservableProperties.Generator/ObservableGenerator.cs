using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace NCoreUtils.ObservableProperties;

[Generator(LanguageNames.CSharp)]
public class ObservableGenerator : IIncrementalGenerator
{
    private const string attributeSource = @"#nullable enable
namespace NCoreUtils
{
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false)]
    internal sealed class HasObservablePropertiesAttribute : System.Attribute
    {
        public HasObservablePropertiesAttribute() { /* noop */ }
    }

    internal sealed class HasObservablePropertyAttribute : System.Attribute
    {
        private System.Type? EqualityComparer { get; set; }

        public HasObservablePropertyAttribute() { /* noop */ }
    }
}";

    private static UTF8Encoding Utf8 { get; } = new(false);

    private static bool IsFieldVariableDeclation(SyntaxNode node)
        => node is VariableDeclaratorSyntax { Parent: VariableDeclarationSyntax { Parent: FieldDeclarationSyntax { Parent: ClassDeclarationSyntax or RecordDeclarationSyntax, AttributeLists.Count: > 0 } } };

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context => context.AddSource("HasObservablePropertyAttribute.g.cs", SourceText.From(attributeSource, Utf8)));

        IncrementalValuesProvider<ObservableFieldTarget> fields = context.SyntaxProvider.ForAttributeWithMetadataName(
            "NCoreUtils.HasObservablePropertyAttribute",
            (node, _) => IsFieldVariableDeclation(node),
            (ctx, cancellationToken) =>
            {
                if (!ctx.SemanticModel.Compilation.HasLanguageVersionAtLeastEqualTo(LanguageVersion.CSharp8))
                {
                    return default;
                }

                FieldDeclarationSyntax fieldDeclaration = (FieldDeclarationSyntax)ctx.TargetNode.Parent!.Parent!;
                IFieldSymbol fieldSymbol = (IFieldSymbol)ctx.TargetSymbol;
                if (fieldSymbol.ContainingSymbol is INamedTypeSymbol host)
                {
                    return new ObservableFieldTarget(ctx.SemanticModel, host, fieldSymbol);
                }
                return default;
            }
        )
        .Where(t => t is not null)!;

        var classes = fields.Collect().SelectMany((targets, cancellationToken) =>
        {
            return targets
                .GroupBy(static t => t.Host, SymbolEqualityComparer.Default)
                .Select(static g => new ObservableClassTarget((INamedTypeSymbol)g.Key!, g.Select(static e => e.Field).ToList()));
        });

        context.RegisterSourceOutput(classes, (ctx, target) =>
        {
            var @namespace = target.Host.ContainingNamespace.ToDisplayString(new(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces));

            SyntaxTriviaList syntaxTriviaList = TriviaList(
                Comment("// <auto-generated/>"),
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))
            );

            var typeDeclarationSyntax = ClassDeclaration(target.Host.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat))
                .AddModifiers(Token(TriviaList(Comment("/// <inheritdoc/>")), SyntaxKind.PartialKeyword, TriviaList()))
                .AddMembers(target.Fields.Select<IFieldSymbol, MemberDeclarationSyntax>(field =>
                {
                    ExpressionSyntax fieldExpression = field.Name switch
                    {
                        "value" => MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("value")),
                        string name => IdentifierName(name)
                    };
                    var propertyName = field.Name.Capitalize();
                    TypeSyntax propertyType = IdentifierName(field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)));

                    var setterBody = IfStatement(
                        BinaryExpression(
                            SyntaxKind.NotEqualsExpression,
                            fieldExpression,
                            IdentifierName("value")
                        ),
                        Block(new StatementSyntax[]
                        {
                            ExpressionStatement(
                                AssignmentExpression(
                                    SyntaxKind.SimpleAssignmentExpression,
                                    fieldExpression,
                                    IdentifierName("value"))
                            ),
                            ExpressionStatement(
                                InvocationExpression(IdentifierName("OnPropertyChanged"))
                                    .AddArgumentListArguments(
                                        Argument(
                                            InvocationExpression(
                                                IdentifierName(
                                                    Identifier(
                                                        TriviaList(),
                                                        SyntaxKind.NameOfKeyword,
                                                        "nameof",
                                                        "nameof",
                                                        TriviaList()
                                                    )
                                                )
                                            )
                                            .AddArgumentListArguments(
                                                Argument(IdentifierName(propertyName))
                                            )
                                        )
                                    )
                            )
                        })
                    );

                    return PropertyDeclaration(propertyType, Identifier(propertyName))
                        .AddModifiers(Token(SyntaxKind.PublicKeyword))
                        .AddAccessorListAccessors(
                            AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                .WithExpressionBody(ArrowExpressionClause(IdentifierName(field.Name)))
                                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                            AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                .WithBody(Block(setterBody))
                        );
                }).ToArray());

            CompilationUnitSyntax unitSyntax = CompilationUnit()
                .AddMembers(
                    NamespaceDeclaration(IdentifierName(@namespace))
                        .WithLeadingTrivia(syntaxTriviaList)
                        .AddMembers(typeDeclarationSyntax)
                )
                .NormalizeWhitespace();
            ctx.AddSource($"{target.Host.Name}.g.cs", unitSyntax.GetText(Utf8));
        });
    }
}