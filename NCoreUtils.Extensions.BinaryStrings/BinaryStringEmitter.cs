using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace NCoreUtils;

internal static class BinaryStringEmitter
{
    private static ArrayTypeSyntax ByteArrayTypeSyntax { get; } = ArrayType(
        PredefinedType(Token(SyntaxKind.ByteKeyword)),
        List(new ArrayRankSpecifierSyntax[]
        {
            ArrayRankSpecifier(SeparatedList(new ExpressionSyntax[]
            {
                OmittedArraySizeExpression()
            }))
        })
    );

    private static QualifiedNameSyntax ByteSpanTypeSyntax { get; } = QualifiedName(
        AliasQualifiedName(alias: "global", name: IdentifierName("System")),
        GenericName(Identifier("ReadOnlySpan"), TypeArgumentList().AddArguments(PredefinedType(Token(SyntaxKind.ByteKeyword))))
    );

    private static SyntaxTriviaList CompilationUnitTriviaList { get; } = TriviaList(
        Comment("// <auto-generated/>"),
        Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))
    );

    private static MemberAccessExpressionSyntax AsByteSpanSyntax { get; } = MemberAccessExpression(
        SyntaxKind.SimpleMemberAccessExpression,
        MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            AliasQualifiedName(alias: "global", name: IdentifierName("System")),
            IdentifierName("MemoryExtensions")
        ),
        GenericName(Identifier("AsSpan"), TypeArgumentList().AddArguments(PredefinedType(Token(SyntaxKind.ByteKeyword))))
    );

    private static SymbolDisplayFormat NamespaceDisplayFormat { get; } = new SymbolDisplayFormat(
        globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
    );

    private static InvocationExpressionSyntax AsByteSpanInvocationExpression(ArgumentSyntax source)
        => InvocationExpression(AsByteSpanSyntax, ArgumentList(SeparatedList(new[]
        {
            source
        })));

    private static FieldDeclarationSyntax EmitBackingFieldSyntax(string methodId, string text, Encoding encoding)
    {
        return FieldDeclaration(
            VariableDeclaration(ByteArrayTypeSyntax,
                SeparatedList(new []
                {
                    VariableDeclarator($"__{methodId}Data")
                        .WithInitializer(EqualsValueClause(
                            Token(SyntaxKind.EqualsToken),
                            ArrayCreationExpression(
                                ByteArrayTypeSyntax,
                                InitializerExpression(SyntaxKind.ArrayInitializerExpression, SeparatedList<ExpressionSyntax>(
                                    encoding.GetBytes(text)
                                        .Select(static @byte => LiteralExpression(
                                            SyntaxKind.NumericLiteralExpression,
                                            Literal("0x" + @byte.ToString("X2"), @byte))
                                        )
                                ))
                            )
                        ))
                })
            )
        ).AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword));
    }

    private static MethodDeclarationSyntax EmitMethodSyntax(IMethodSymbol method, string methodId)
    {
        return MethodDeclaration(ByteSpanTypeSyntax, method.Name)
            .AddMethodAccessModifiers(method.DeclaredAccessibility)
            .AddModifiers(Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword))
            .WithExpressionBody(ArrowExpressionClause(
                AsByteSpanInvocationExpression(Argument(IdentifierName($"__{methodId}Data")))
            ))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }

    public static ClassDeclarationSyntax EmitClassSyntax(BinaryStringClassTarget target)
    {
        return ClassDeclaration(target.ContainingType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat))
            .AddModifiers(Token(TriviaList(Comment("/// <inheritdoc/>")), SyntaxKind.PartialKeyword, TriviaList()))
            .AddMembers(target.Methods
                .Select<BinaryStringMethodTarget, MemberDeclarationSyntax>(method => EmitBackingFieldSyntax(method.Method.Name, method.Text, method.Encoding))
                .ToArray()
            )
            .AddMembers(target.Methods
                .Select<BinaryStringMethodTarget, MemberDeclarationSyntax>(method => EmitMethodSyntax(method.Method, method.Method.Name))
                .ToArray()
            );
    }

    public static CompilationUnitSyntax EmitCompilationUnit(BinaryStringClassTarget target)
    {
        return CompilationUnit()
            .AddMembers(
                NamespaceDeclaration(IdentifierName(target.ContainingType.ContainingNamespace.ToDisplayString(NamespaceDisplayFormat)))
                    .WithLeadingTrivia(CompilationUnitTriviaList)
                    .AddMembers(EmitClassSyntax(target))
            )
            .NormalizeWhitespace();
    }
}